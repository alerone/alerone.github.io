import{AnimationClip,AnimationMixer,Euler,Matrix4,Quaternion,QuaternionKeyframeTrack,SkeletonHelper,Vector2,Vector3,VectorKeyframeTrack}from"three";function retarget(e,t,n={}){const o=new Vector3,r=new Quaternion,i=new Vector3,a=new Matrix4,s=new Matrix4,l=new Matrix4;n.preserveMatrix=void 0===n.preserveMatrix||n.preserveMatrix,n.preservePosition=void 0===n.preservePosition||n.preservePosition,n.preserveHipPosition=void 0!==n.preserveHipPosition&&n.preserveHipPosition,n.useTargetMatrix=void 0!==n.useTargetMatrix&&n.useTargetMatrix,n.hip=void 0!==n.hip?n.hip:"hip",n.names=n.names||{};const p=t.isObject3D?t.skeleton.bones:getBones(t),m=e.isObject3D?e.skeleton.bones:getBones(e);let c,u,x,f,d;if(e.isObject3D?e.skeleton.pose():(n.useTargetMatrix=!0,n.preserveMatrix=!1),n.preservePosition){d=[];for(let e=0;e<m.length;e++)d.push(m[e].position.clone())}if(n.preserveMatrix){e.updateMatrixWorld(),e.matrixWorld.identity();for(let t=0;t<e.children.length;++t)e.children[t].updateMatrixWorld(!0)}if(n.offsets){c=[];for(let e=0;e<m.length;++e)u=m[e],x=n.names[u.name]||u.name,n.offsets[x]&&(u.matrix.multiply(n.offsets[x]),u.matrix.decompose(u.position,u.quaternion,u.scale),u.updateMatrixWorld()),c.push(u.matrixWorld.clone())}for(let t=0;t<m.length;++t){if(u=m[t],x=n.names[u.name]||u.name,f=getBoneByName(x,p),l.copy(u.matrixWorld),f){if(f.updateMatrixWorld(),n.useTargetMatrix?s.copy(f.matrixWorld):(s.copy(e.matrixWorld).invert(),s.multiply(f.matrixWorld)),i.setFromMatrixScale(s),s.scale(i.set(1/i.x,1/i.y,1/i.z)),l.makeRotationFromQuaternion(r.setFromRotationMatrix(s)),e.isObject3D){const t=m.indexOf(u),n=c?c[t]:a.copy(e.skeleton.boneInverses[t]).invert();l.multiply(n)}l.copyPosition(s)}u.parent&&u.parent.isBone?(u.matrix.copy(u.parent.matrixWorld).invert(),u.matrix.multiply(l)):u.matrix.copy(l),n.preserveHipPosition&&x===n.hip&&u.matrix.setPosition(o.set(0,u.position.y,0)),u.matrix.decompose(u.position,u.quaternion,u.scale),u.updateMatrixWorld()}if(n.preservePosition)for(let e=0;e<m.length;++e)u=m[e],x=n.names[u.name]||u.name,x!==n.hip&&u.position.copy(d[e]);n.preserveMatrix&&e.updateMatrixWorld(!0)}function retargetClip(e,t,n,o={}){o.useFirstFramePosition=void 0!==o.useFirstFramePosition&&o.useFirstFramePosition,o.fps=void 0!==o.fps?o.fps:30,o.names=o.names||[],t.isObject3D||(t=getHelperFromSkeleton(t));const r=Math.round(n.duration*(o.fps/1e3)*1e3),i=1/o.fps,a=[],s=new AnimationMixer(t),l=getBones(e.skeleton),p=[];let m,c,u,x,f;s.clipAction(n).play(),s.update(0),t.updateMatrixWorld();for(let n=0;n<r;++n){const a=n*i;retarget(e,t,o);for(let e=0;e<l.length;++e)f=o.names[l[e].name]||l[e].name,u=getBoneByName(f,t.skeleton),u&&(c=l[e],x=p[e]=p[e]||{bone:c},o.hip===f&&(x.pos||(x.pos={times:new Float32Array(r),values:new Float32Array(3*r)}),o.useFirstFramePosition&&(0===n&&(m=c.position.clone()),c.position.sub(m)),x.pos.times[n]=a,c.position.toArray(x.pos.values,3*n)),x.quat||(x.quat={times:new Float32Array(r),values:new Float32Array(4*r)}),x.quat.times[n]=a,c.quaternion.toArray(x.quat.values,4*n));s.update(i),t.updateMatrixWorld()}for(let e=0;e<p.length;++e)x=p[e],x&&(x.pos&&a.push(new VectorKeyframeTrack(".bones["+x.bone.name+"].position",x.pos.times,x.pos.values)),a.push(new QuaternionKeyframeTrack(".bones["+x.bone.name+"].quaternion",x.quat.times,x.quat.values)));return s.uncacheAction(n),new AnimationClip(n.name,-1,a)}function getHelperFromSkeleton(e){const t=new SkeletonHelper(e.bones[0]);return t.skeleton=e,t}function getSkeletonOffsets(e,t,n={}){const o=new Vector3,r=new Vector3,i=new Vector3,a=new Vector3,s=new Vector2,l=new Vector2;n.hip=void 0!==n.hip?n.hip:"hip",n.names=n.names||{},t.isObject3D||(t=getHelperFromSkeleton(t));const p=Object.keys(n.names),m=Object.values(n.names),c=t.isObject3D?t.skeleton.bones:getBones(t),u=e.isObject3D?e.skeleton.bones:getBones(e),x=[];let f,d,g,M;for(e.skeleton.pose(),M=0;M<u.length;++M)if(f=u[M],g=n.names[f.name]||f.name,d=getBoneByName(g,c),d&&g!==n.hip){const e=getNearestBone(f.parent,p),t=getNearestBone(d.parent,m);e.updateMatrixWorld(),t.updateMatrixWorld(),o.setFromMatrixPosition(e.matrixWorld),r.setFromMatrixPosition(f.matrixWorld),i.setFromMatrixPosition(t.matrixWorld),a.setFromMatrixPosition(d.matrixWorld),s.subVectors(new Vector2(r.x,r.y),new Vector2(o.x,o.y)).normalize(),l.subVectors(new Vector2(a.x,a.y),new Vector2(i.x,i.y)).normalize();const n=s.angle()-l.angle(),c=(new Matrix4).makeRotationFromEuler(new Euler(0,0,n));f.matrix.multiply(c),f.matrix.decompose(f.position,f.quaternion,f.scale),f.updateMatrixWorld(),x[g]=c}return x}function renameBones(e,t){const n=getBones(e);for(let e=0;e<n.length;++e){const o=n[e];t[o.name]&&(o.name=t[o.name])}return this}function getBones(e){return Array.isArray(e)?e:e.bones}function getBoneByName(e,t){for(let n=0,o=getBones(t);n<o.length;n++)if(e===o[n].name)return o[n]}function getNearestBone(e,t){for(;e.isBone;){if(-1!==t.indexOf(e.name))return e;e=e.parent}}function findBoneTrackData(e,t){const n=/\[(.*)\]\.(.*)/,o={name:e};for(let r=0;r<t.length;++r){const i=n.exec(t[r].name);i&&e===i[1]&&(o[i[2]]=r)}return o}function getEqualsBonesNames(e,t){const n=getBones(e),o=getBones(t),r=[];e:for(let e=0;e<n.length;e++){const t=n[e].name;for(let e=0;e<o.length;e++)if(t===o[e].name){r.push(t);continue e}}return r}function clone(e){const t=new Map,n=new Map,o=e.clone();return parallelTraverse(e,o,(function(e,o){t.set(o,e),n.set(e,o)})),o.traverse((function(e){if(!e.isSkinnedMesh)return;const o=e,r=t.get(e),i=r.skeleton.bones;o.skeleton=r.skeleton.clone(),o.bindMatrix.copy(r.bindMatrix),o.skeleton.bones=i.map((function(e){return n.get(e)})),o.bind(o.skeleton,o.bindMatrix)})),o}function parallelTraverse(e,t,n){n(e,t);for(let o=0;o<e.children.length;o++)parallelTraverse(e.children[o],t.children[o],n)}export{retarget,retargetClip,getHelperFromSkeleton,getSkeletonOffsets,renameBones,getBones,getBoneByName,getNearestBone,findBoneTrackData,getEqualsBonesNames,clone};